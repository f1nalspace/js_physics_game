<!DOCTYPE html>
<html>
<head>
    <title>Circle segment</title>
    <meta http-equiv="X-UA-Compatible" content="IE=7"/>
    <script src="../../js-moduleloader/szue.js"></script>
</head>
<body>
<canvas id="canvas" height="720" width="1280"></canvas>
<script type="text/javascript">
// shim layer with setTimeout fallback
var requestAnimFrame = (function () {
    return window.requestAnimationFrame ||
            window.webkitRequestAnimationFrame ||
            window.mozRequestAnimationFrame ||
            window.oRequestAnimationFrame ||
            window.msRequestAnimationFrame ||
            function (callback) {
                window.setTimeout(callback, 1000 / 60);
            };
})();

function addListener(element, event, fn) {
    // Use addEventListener if available
    if (element.addEventListener) {
        element.addEventListener(event, fn, false);
        // Otherwise use attachEvent, set this and event
    } else if (element.attachEvent) {
        element.attachEvent('on' + event, (function (el) {
            return function () {
                fn.call(el, window.event);
            };
        }(element)));

        // Break closure and primary circular reference to element
        element = null;
    }
}

szue.ready(function () {
    var canvas = document.getElementById("canvas");
    var ctx = canvas.getContext("2d");
    var w = canvas.width;
    var h = canvas.height;
    var mouse = {x: -1, y: -1};
    var mousestate = {};

    var getY = function (y) {
        return h - 1 - y;
    };

    /**
     * Convert downward to upward radians
     * From 1.5 PI upwards to 0.5 PI upwards (Unit circle)
     * @param r
     * @returns {number}
     */
    var getAngle = function (r) {
        return Math.PI * 2 - r;
    };

    var updatePos = function (pos, x, y) {
        pos.x = (x - canvas.getBoundingClientRect().left) * (canvas.width / canvas.offsetWidth);
        pos.y = getY(y - canvas.getBoundingClientRect().top) * (canvas.height / canvas.offsetHeight);
    };

    // Disable selection
    canvas.onselectstart = function () {
        return false;
    };

    // Add mouse listeners
    addListener(canvas, "mousedown", function (e) {
        updatePos(mouse, e.clientX, e.clientY);
        mousestate[e.button] = true;
    });
    addListener(canvas, "mousemove", function (e) {
        updatePos(mouse, e.clientX, e.clientY);
    });
    addListener(canvas, "mouseup", function (e) {
        updatePos(mouse, e.clientX, e.clientY);
        mousestate[e.button] = false;
    });
    addListener(canvas, "mouseout", function (e) {
        updatePos(mouse, e.clientX, e.clientY);
    });

    var pi180 = Math.PI / 180;
    var TAU = Math.PI * 2;

    // normalize ang so that it lies in 0 - PI*2
    function normalizeAngle(ang) {
        while (ang < 0) {
            ang += TAU;
        }
        while (ang > TAU) {
            ang -= TAU;
        }
        return ang;
    }

    var circleCenter = {x: w * 0.5, y: h * 0.5};
    var circleRadius = 150;
    var circleRadiusSq = circleRadius * circleRadius;

    var inputStartAngle = pi180 * 90;
    var inputLengthAngle = -Math.PI * 2;
    var inputData = [75, 25, 33, 2, 100];
    var inputColors = ["green", "yellow", "blue", "brown", "cyan", "darkkhaki", "darksalmon", "deeppink"];

    var maxDataSum = 0;
    inputData.forEach(function (value) {
        maxDataSum += value;
    });
    var dataFactor = 1.0 / maxDataSum;
    var circleClockwise = inputLengthAngle >= 0;

    (function renderFrame() {
        requestAnimFrame(renderFrame, null);

        var lines = [];

        lines.push("Input start angle: " + inputStartAngle);
        lines.push("Input length angle: " + inputLengthAngle);
        lines.push("Input data: [" + inputData.join(", ") + "]");
        lines.push("Data factor: " + dataFactor + ", max sum: " + maxDataSum);

        var fontSize = 16;
        ctx.font = "bold " + fontSize + "px arial";
        ctx.textBaseline = "top";

        var i;

        ctx.clearRect(0, 0, w, h);

        ctx.fillStyle = "cornflowerblue";
        ctx.fillRect(0, 0, w, h);

        var subVec = {x: mouse.x - circleCenter.x, y: mouse.y - circleCenter.y};
        var l = subVec.x * subVec.x + subVec.y * subVec.y;

        var segmentStart = inputStartAngle;
        for (i = 0; i < inputData.length; i++) {
            var segmentLength = inputData[i] * dataFactor * inputLengthAngle;
            lines.push(i + "=" + inputData[i] * dataFactor.toFixed(3) + " : " + segmentStart + ", " + segmentLength);

            var segmentRealStart = segmentStart;
            var segmentRealLen = segmentLength;

            segmentRealStart = normalizeAngle(segmentRealStart);
            segmentRealLen = Math.abs(segmentRealLen);

            var segmentRealEnd;
            if (circleClockwise) {
                // clockwise means we have to subtract the length
                segmentRealEnd = segmentRealStart - segmentRealLen;

                // ... and swap start and end, so start is always less than end
                var tmp = segmentRealEnd;
                segmentRealEnd = segmentRealStart;
                segmentRealStart = tmp;

                // normalize circleStart while conservating the length (end - start)
                // can only be negative, not > 2*PI
                while (segmentRealStart < 0) {
                    segmentRealStart += TAU;
                    segmentRealEnd += TAU;
                }
            } else {
                segmentRealEnd = segmentRealStart + segmentRealLen;
            }

            var angle = normalizeAngle(Math.atan2(subVec.y, subVec.x) - segmentRealStart);
            var drawingAngle = Math.atan2(subVec.y, subVec.x);
            var insideRadius = l <= circleRadiusSq;
            var insideSegment = angle <= segmentRealLen;
            var drawingStartAngle = getAngle(segmentRealStart);
            var drawingEndAngle = getAngle(segmentRealEnd);
            var drawingColor = inputColors[i % inputColors.length];

            lines.push(i + "=" + inputData[i] * dataFactor.toFixed(3) + " : " + segmentRealStart + "->" + segmentRealEnd);
            lines.push(i + "=" + inputData[i] * dataFactor.toFixed(3) + " : " + angle + ", " + segmentRealLen);

            ctx.beginPath();
            ctx.arc(circleCenter.x, getY(circleCenter.y), circleRadius, drawingStartAngle, drawingEndAngle, true);
            ctx.lineTo(circleCenter.x, getY(circleCenter.y));
            ctx.closePath();
            ctx.fillStyle = insideSegment && insideRadius ? "red" : drawingColor;
            ctx.fill();

            /*
            ctx.beginPath();
            ctx.moveTo(circleCenter.x, getY(circleCenter.y));
            ctx.lineTo(circleCenter.x + Math.cos(segmentRealStart) * circleRadius, getY(circleCenter.y + Math.sin(segmentRealStart) * circleRadius));
            ctx.lineWidth = 3;
            ctx.strokeStyle = "green";
            ctx.stroke();
            ctx.lineWidth = 2;

            ctx.beginPath();
            ctx.moveTo(circleCenter.x, getY(circleCenter.y));
            ctx.lineTo(circleCenter.x + Math.cos(segmentRealEnd) * circleRadius, getY(circleCenter.y + Math.sin(segmentRealEnd) * circleRadius));
            ctx.lineWidth = 2;
            ctx.strokeStyle = "yellow";
            ctx.stroke();
            ctx.lineWidth = 1;
            */

            ctx.beginPath();
            ctx.moveTo(circleCenter.x, getY(circleCenter.y));
            ctx.lineTo(circleCenter.x + Math.cos(drawingAngle) * circleRadius, getY(circleCenter.y + Math.sin(drawingAngle) * circleRadius));
            ctx.lineWidth = 3;
            ctx.strokeStyle = "black";
            ctx.stroke();
            ctx.lineWidth = 1;

            if (circleClockwise) {
                segmentStart -= segmentRealLen;
            } else {
                segmentStart += segmentRealLen;
            }
        }

        ctx.beginPath();
        ctx.arc(mouse.x, getY(mouse.y), 4, 0, Math.PI * 2, false);
        ctx.strokeStyle = "yellow";
        ctx.stroke();

        var padding = 1.25;
        ctx.fillStyle = "black";

        for (i = 0; i < lines.length; i++) {
            ctx.fillText(lines[i], 10, 10 + fontSize * padding * i);
        }

    })();
});
</script>
</body>
</html>