<!doctype html>
<html>
<head>
    <title>Pie labels</title>
    <meta name="viewport" content="initial-scale = 1, user-scalable = no">
    <meta charset="utf-8">
    <style>
        canvas {
            border: 1px solid #000000;
        }
    </style>
    <script type="text/javascript" src="../3rd/seedrandom.js"></script>
</head>
<body>
<canvas id="canvas" width="800" height="600"></canvas>
<script type="text/javascript">
Math.seedrandom('123 Hello World');

(function () {
    function Vec2(x, y) {
        this.x = x || 0;
        this.y = y || 0;
    }

    Vec2.prototype.add = function (v) {
        return new Vec2(this.x + v.x, this.y + v.y);
    };

    Vec2.prototype.sub = function (v) {
        return new Vec2(this.x - v.x, this.y - v.y);
    };

    Vec2.prototype.dot = function (v) {
        return this.x * v.x + this.y * v.y;
    };

    Vec2.prototype.flip = function () {
        return new Vec2(-this.x, -this.y);
    };

    Vec2.prototype.magnitude = function () {
        return Math.sqrt(this.dot(this));
    };

    Vec2.prototype.normalize = function () {
        var l = this.magnitude();
        return new Vec2(this.x / l, this.y / l);
    };

    Vec2.prototype.sign = function () {
        var x = this.x > 0 ? 1 : (this.x < 0 ? -1 : 0);
        var y = this.y > 0 ? 1 : (this.y < 0 ? -1 : 0);
        return new Vec2(x, y);
    };

    Vec2.prototype.multScalar = function (scalar) {
        return new Vec2(this.x * scalar, this.y * scalar);
    };

    Vec2.prototype.set = function (v) {
        this.x = v.x;
        this.y = v.y;
    };

    function getTextSize(r, text, rotation) {
        var w = r.measureText(text).width;
        var fontSizeRex = /([0-9]+(px|pt))\s(.*)/ig;
        var fontMatches = fontSizeRex.exec(r.font);
        var fontHeight = parseInt(fontMatches[1], 10);
        return new Vec2(w, fontHeight);
    }

    var i;

    var dataCount = 35;
    var data = [];
    for (i = 0; i < dataCount; ++i) {
        var value = 100 * Math.random();
        data.push({
            instances: value,
            label: ""
        });
    }
    var startRad = 0;
    var lenRad = Math.PI * 2;
    var sliceOffset = 0;
    var textOffset = 0;

    var canvas = document.getElementById("canvas");
    var ctx = canvas.getContext("2d");

    ctx.font = "normal 20pt arial";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";

    var w = canvas.width;
    var h = canvas.height;

    var radius = Math.min(w, h) * 0.5;

    var center = new Vec2(w * 0.5, h * 0.5);

    var dataSum = 0;
    var segmentAngle, dir, offset, segment;
    for (i = 0; i < dataCount; ++i) {
        dataSum += data[i].instances;
    }
    var dataSumOverOne = 1.0 / dataSum;
    for (i = 0; i < dataCount; ++i) {
        data[i].label = (data[i].instances * dataSumOverOne * 100).toFixed(3) + " %";
    }

    var segments = [];

    var cumulativeAngle = startRad;
    for (i = 0; i < dataCount; ++i) {
        segmentAngle = data[i].instances * dataSumOverOne * lenRad;
        dir = new Vec2(Math.cos(cumulativeAngle + segmentAngle * 0.5), Math.sin(cumulativeAngle + segmentAngle * 0.5));
        offset = new Vec2(dir.x * sliceOffset, dir.y * sliceOffset);
        segments.push({
            dataIndex: i,
            startAngle: cumulativeAngle,
            segmentAngle: segmentAngle,
            dir: dir,
            offset: offset
        });
        cumulativeAngle += segmentAngle;
    }

    var edgeSize = new Vec2(w, h);
    var labelAxis = [new Vec2(1, 0), new Vec2(0, 1)];
    var labels = [];
    var shapes = [];
    var activeRadius = radius;
    var radiusAdjusted = false;

    var iterations = 0;
    var maxIterations = 1000;
    var spacingAlpha = 1.0;
    var correctionEpsilon = 0.1;
    var alpha = 0.8;
    var algo = "SAT";

    var init = function () {
        labels = [];
        shapes = [];
        iterations = 0;
        activeRadius = radius;
        radiusAdjusted = false;
        for (i = 0; i < segments.length; ++i) {
            segment = segments[i];

            var text = data[segment.dataIndex].label;
            var textPos = new Vec2(center.x + segment.offset.x + segment.dir.x * (radius + textOffset), center.y + segment.offset.y + segment.dir.y * (radius + textOffset));
            var textSize = getTextSize(ctx, text, 0);

            var textDir = textPos.sub(center).sign();

            if (Math.abs(textDir.x) > 0) {
                textPos.x += textDir.x * textSize.x * 0.5;
            }
            if (Math.abs(textDir.y) > 0) {
                textPos.y += textDir.y * textSize.y * 0.5;
            }

            labels.push({
                type: "label",
                mass: 1,
                pos: textPos,
                size: textSize,
                text: text,
                project: function (axis) {
                    var p = Math.abs(axis.dot(labelAxis[0])) * this.size.x * 0.5 + Math.abs(axis.dot(labelAxis[1])) * this.size.y * 0.5;
                    return new Vec2(-p, p);
                },
                getAxis: function (other) {
                    return [new Vec2(0, 1), new Vec2(1, 0)];
                },
                getClosest: function (point) {
                    var a = ["x", "y"];
                    var output = new Vec2(0, 0);
                    for (var i = 0; i < 2; i++) {
                        var c = a[i];
                        var v = point[c];
                        v = Math.max(v, this.pos[c] - this.size[c] * 0.5);
                        v = Math.min(v, this.pos[c] + this.size[c] * 0.5);
                        output[c] = v;
                    }
                    return output;
                }
            });
        }

        shapes.push({
            type: "circle",
            pos: center,
            radius: radius,
            mass: 0,
            project: function () {
                return new Vec2(-this.radius, this.radius)
            },
            getAxis: function (other) {
                if (other.type == "label") {
                    var closest = other.getClosest(this.pos);
                    var closestDistance = closest.sub(this.pos);
                    var axis = closestDistance.normalize();
                    return [axis];
                }
                return [];
            }

        });

        shapes.push({
            type: "edge",
            pos: new Vec2(w * 0.5, 0 - edgeSize.y * 0.5),
            size: new Vec2(w, edgeSize.y),
            mass: 0,
            project: function (axis) {
                var p = Math.abs(axis.dot(labelAxis[0])) * this.size.x * 0.5 + Math.abs(axis.dot(labelAxis[1])) * this.size.y * 0.5;
                return new Vec2(-p, p);
            },
            getAxis: function (other) {
                return [new Vec2(0, 1), new Vec2(1, 0)];
            },
            getClosest: function (point) {
                var a = ["x", "y"];
                var output = new Vec2(0, 0);
                for (var i = 0; i < 2; i++) {
                    var c = a[i];
                    var v = point[c];
                    v = Math.max(v, this.pos[c] - this.size[c] * 0.5);
                    v = Math.min(v, this.pos[c] + this.size[c] * 0.5);
                    output[c] = v;
                }
                return output;
            }
        });

        shapes.push({
            type: "edge",
            pos: new Vec2(w * 0.5, h + edgeSize.y * 0.5),
            size: new Vec2(w, edgeSize.y),
            mass: 0,
            project: function (axis) {
                var p = Math.abs(axis.dot(labelAxis[0])) * this.size.x * 0.5 + Math.abs(axis.dot(labelAxis[1])) * this.size.y * 0.5;
                return new Vec2(-p, p);
            },
            getAxis: function (other) {
                return [new Vec2(0, 1), new Vec2(1, 0)];
            },
            getClosest: function (point) {
                var a = ["x", "y"];
                var output = new Vec2(0, 0);
                for (var i = 0; i < 2; i++) {
                    var c = a[i];
                    var v = point[c];
                    v = Math.max(v, this.pos[c] - this.size[c] * 0.5);
                    v = Math.min(v, this.pos[c] + this.size[c] * 0.5);
                    output[c] = v;
                }
                return output;
            }
        });

        shapes.push({
            type: "edge",
            pos: new Vec2(0 - edgeSize.x * 0.5, h * 0.5),
            size: new Vec2(edgeSize.x, h),
            mass: 0,
            project: function (axis) {
                var p = Math.abs(axis.dot(labelAxis[0])) * this.size.x * 0.5 + Math.abs(axis.dot(labelAxis[1])) * this.size.y * 0.5;
                return new Vec2(-p, p);
            },
            getAxis: function (other) {
                return [new Vec2(0, 1), new Vec2(1, 0)];
            },
            getClosest: function (point) {
                var a = ["x", "y"];
                var output = new Vec2(0, 0);
                for (var i = 0; i < 2; i++) {
                    var c = a[i];
                    var v = point[c];
                    v = Math.max(v, this.pos[c] - this.size[c] * 0.5);
                    v = Math.min(v, this.pos[c] + this.size[c] * 0.5);
                    output[c] = v;
                }
                return output;
            }
        });

        shapes.push({
            type: "edge",
            pos: new Vec2(w + edgeSize.x * 0.5, h * 0.5),
            size: new Vec2(edgeSize.x, h),
            mass: 0,
            project: function (axis) {
                var p = Math.abs(axis.dot(labelAxis[0])) * this.size.x * 0.5 + Math.abs(axis.dot(labelAxis[1])) * this.size.y * 0.5;
                return new Vec2(-p, p);
            },
            getAxis: function (other) {
                return [new Vec2(0, 1), new Vec2(1, 0)];
            },
            getClosest: function (point) {
                var a = ["x", "y"];
                var output = new Vec2(0, 0);
                for (var i = 0; i < 2; i++) {
                    var c = a[i];
                    var v = point[c];
                    v = Math.max(v, this.pos[c] - this.size[c] * 0.5);
                    v = Math.min(v, this.pos[c] + this.size[c] * 0.5);
                    output[c] = v;
                }
                return output;
            }
        });

        for (i = 0; i < labels.length; i++) {
            shapes.push(labels[i]);
        }
    };

    var render = function () {
        ctx.fillStyle = "white";
        ctx.fillRect(0, 0, w, h);

        ctx.save();
        //ctx.scale(0.6, 0.6);
        //ctx.translate(200, 200);

        ctx.strokeStyle = "purple";
        ctx.strokeRect(0, 0, w, h);

        var i, offset, dir, label, anchor;

        for (i = 0; i < segments.length; ++i) {
            offset = segments[i].offset;
            dir = segments[i].dir;

            ctx.beginPath();
            ctx.arc(center.x + offset.x + dir.x * activeRadius, center.y + offset.y + dir.y * activeRadius, 4, 0, Math.PI * 2, false);
            ctx.strokeStyle = "red";
            ctx.stroke();

            ctx.beginPath();
            ctx.arc(center.x + offset.x, center.y + offset.y, activeRadius, segments[i].startAngle, segments[i].startAngle + segments[i].segmentAngle, false);
            ctx.lineTo(center.x + offset.x, center.y + offset.y);
            ctx.closePath();
            ctx.strokeStyle = "black";
            ctx.stroke();
        }

        for (i = 0; i < labels.length; ++i) {
            label = labels[i];

            ctx.fillStyle = "black";
            ctx.fillText(label.text, label.pos.x, label.pos.y);

            ctx.strokeStyle = "blue";
            ctx.strokeRect(label.pos.x - label.size.x * 0.5, label.pos.y - label.size.y * 0.5, label.size.x, label.size.y);
        }

        for (i = 0; i < segments.length; ++i) {
            offset = segments[i].offset;
            dir = segments[i].dir;
            label = labels[i];
            anchor = new Vec2(center.x + offset.x + dir.x * activeRadius, center.y + offset.y + dir.y * activeRadius);
            ctx.beginPath();
            ctx.moveTo(anchor.x, anchor.y);
            ctx.lineTo(label.pos.x, label.pos.y);
            ctx.strokeStyle = "blue";
            ctx.stroke();
        }

        var labelMin = new Vec2(labels[0].pos.x, labels[0].pos.y);
        var labelMax = new Vec2(labels[0].pos.x, labels[0].pos.y);
        for (i = 0; i < labels.length; ++i) {
            label = labels[i];
            labelMin.x = Math.min(labelMin.x, labels[i].pos.x - labels[i].size.x * 0.5);
            labelMin.y = Math.min(labelMin.y, labels[i].pos.y - labels[i].size.y * 0.5);
            labelMax.x = Math.max(labelMax.x, labels[i].pos.x + labels[i].size.x * 0.5);
            labelMax.y = Math.max(labelMax.y, labels[i].pos.y + labels[i].size.y * 0.5);
        }

        for (i = 0; i < shapes.length; ++i) {
            var shape = shapes[i];
            if (shape.type == "edge") {
                ctx.strokeStyle = "red";
                ctx.strokeRect(shape.pos.x - shape.size.x * 0.5, shape.pos.y - shape.size.y * 0.5, shape.size.x, shape.size.y);
            }
        }

        //ctx.strokeStyle = "green";
        //ctx.strokeRect(labelMin.x, labelMin.y, labelMax.x - labelMin.x, labelMax.y - labelMin.y);

        ctx.restore();
    };

    var adjustRadius = function () {
        var label, i;

        var labelMin = new Vec2(labels[0].pos.x, labels[0].pos.y);
        var labelMax = new Vec2(labels[0].pos.x, labels[0].pos.y);
        for (i = 0; i < labels.length; ++i) {
            label = labels[i];
            labelMin.x = Math.min(labelMin.x, labels[i].pos.x - labels[i].size.x * 0.5);
            labelMin.y = Math.min(labelMin.y, labels[i].pos.y - labels[i].size.y * 0.5);
            labelMax.x = Math.max(labelMax.x, labels[i].pos.x + labels[i].size.x * 0.5);
            labelMax.y = Math.max(labelMax.y, labels[i].pos.y + labels[i].size.y * 0.5);
        }

        var x11 = 0;
        var x12 = w;
        var y11 = 0;
        var y12 = h;
        var x21 = labelMin.x;
        var x22 = labelMin.x + (labelMax.x - labelMin.x);
        var y21 = labelMin.y;
        var y22 = labelMin.y + (labelMax.y - labelMin.y);
        var leftOverlap = x21 - x11 < 0 ? Math.abs(x21 - x11) : 0;
        var rightOverlap = x22 - x12 > 0 ? x22 - x12 : 0;
        var topOverlap = y21 - y11 < 0 ? Math.abs(y21 - y11) : 0;
        var bottomOverlap = y22 - y12 > 0 ? y22 - y12 : 0;

        var greatestOverlap = 0;
        if (leftOverlap > greatestOverlap) {
            greatestOverlap = leftOverlap;
        }
        if (rightOverlap > greatestOverlap) {
            greatestOverlap = rightOverlap;
        }
        if (topOverlap > greatestOverlap) {
            greatestOverlap = topOverlap;
        }
        if (bottomOverlap > greatestOverlap) {
            greatestOverlap = bottomOverlap;
        }
        if (greatestOverlap > 0) {
            activeRadius -= greatestOverlap;
            var d = activeRadius / radius;
            for (i = 0; i < labels.length; ++i) {
                label = labels[i];
                var distance = label.pos.sub(center);
                var len = distance.magnitude();
                var dir = distance.multScalar(1.0 / len);
                label.pos = center.add(dir.multScalar(len * d));
            }
            render();
            radiusAdjusted = true;
            shapes[0].radius = activeRadius;
            requestAnimationFrame(solveLabelCollisions);
        }
    };

    var solveLabelCollisions = function () {
        var i, j, k;
        var shapeA, shapeB, label, axis;

        var found = false;
        if (iterations++ < maxIterations) {
            var maxCorrection = 0;
            for (i = 0; i < shapes.length - 1; ++i) {
                shapeA = shapes[i];
                for (j = i + 1; j < shapes.length; ++j) {
                    shapeB = shapes[j];

                    if (shapeA.mass == 0 && shapeB.mass == 0) {
                        continue;
                    }

                    if (!radiusAdjusted && (shapeA.type == "edge" || shapeB.type == "edge")) {
                        continue;
                    }

                    if (algo == "Relax") {
                        // See: http://jsfiddle.net/7aqt3681/
                        if (shapeA.type != "label" || shapeB.type != "label") {
                            continue;
                        }

                        var distanceToCenterA = center.sub(shapeA.pos);
                        var distanceToCenterB = center.sub(shapeB.pos);
                        var dotA = distanceToCenterA.dot(new Vec2(1, 0));
                        var dotB = distanceToCenterB.dot(new Vec2(1, 0));
                        var anchorA = dotA > 0 ? "end" : "start";
                        var anchorB = dotB > 0 ? "end" : "start";

                        if (anchorA != anchorB) {
                            continue;
                        }

                        var spacing = (shapeA.size.y + shapeB.size.y) * 0.5 * spacingAlpha;
                        var deltaY = shapeA.pos.y - shapeB.pos.y;
                        if (Math.abs(deltaY) > spacing) {
                            continue;
                        }

                        found = true;
                        var sign = deltaY > 0 ? 1 : -1;
                        var adjust = sign * alpha;
                        shapeA.pos.y += adjust;
                        shapeB.pos.y -= adjust;
                    } else {
                        var collisionAxis = shapeA.getAxis(shapeB).concat(shapeB.getAxis(shapeA));

                        var minDir = new Vec2();
                        var minOverlap = null;

                        var relOffset = shapeB.pos.sub(shapeA.pos);

                        for (k = 0; k < collisionAxis.length; ++k) {
                            axis = collisionAxis[k];
                            var projDistance = relOffset.dot(axis);

                            var projA = shapeA.project(axis).multScalar(spacingAlpha);
                            var projB = shapeB.project(axis).multScalar(spacingAlpha);

                            projA.x += projDistance;
                            projA.y += projDistance;

                            var E = projA.x - projB.y;
                            var L = projB.x - projA.y;

                            var overlap = E > L ? E : L;
                            if (overlap < 0) {
                                if (minOverlap == null || overlap > minOverlap) {
                                    minOverlap = overlap;
                                    minDir.set(axis);
                                }
                            } else {
                                minOverlap = null;
                                break;
                            }
                        }

                        if (minOverlap != null) {
                            if (relOffset.dot(minDir) < 0) {
                                minDir = minDir.flip();
                            }
                            var invMassA = shapeA.mass > 0 ? 1.0 / shapeA.mass : 0;
                            var invMassB = shapeB.mass > 0 ? 1.0 / shapeB.mass : 0;
                            var correction = minOverlap;
                            shapeB.pos.x -= minDir.x * correction * invMassB * alpha;
                            shapeB.pos.y -= minDir.y * correction * invMassB * alpha;
                            shapeA.pos.x += minDir.x * correction * invMassA * alpha;
                            shapeA.pos.y += minDir.y * correction * invMassA * alpha;

                            maxCorrection = Math.max(maxCorrection, -minOverlap);

                            found = true;
                        }
                    }
                }
            }

            if (maxCorrection < correctionEpsilon && algo == "SAT") {
                // Correction penetrations are very small - no need to adjust further
                found = false;
            }
        }


        var labelMin = new Vec2(labels[0].pos.x, labels[0].pos.y);
        var labelMax = new Vec2(labels[0].pos.x, labels[0].pos.y);
        for (i = 0; i < labels.length; ++i) {
            label = labels[i];
            labelMin.x = Math.min(labelMin.x, labels[i].pos.x - labels[i].size.x * 0.5);
            labelMin.y = Math.min(labelMin.y, labels[i].pos.y - labels[i].size.y * 0.5);
            labelMax.x = Math.max(labelMax.x, labels[i].pos.x + labels[i].size.x * 0.5);
            labelMax.y = Math.max(labelMax.y, labels[i].pos.y + labels[i].size.y * 0.5);
        }

        ctx.strokeStyle = "green";
        ctx.strokeRect(labelMin.x, labelMin.y, labelMax.x - labelMin.x, labelMax.y - labelMin.y);

        render();

        if (found) {
            requestAnimationFrame(solveLabelCollisions);
        } else {
            if (!radiusAdjusted) {
                requestAnimationFrame(adjustRadius);
            }
        }
    };

    init();
    requestAnimationFrame(solveLabelCollisions);
}());
</script>
</body>
</html>
